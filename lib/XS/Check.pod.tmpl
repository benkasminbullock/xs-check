[% start_year=2017 %]
[% MACRO example(file) BLOCK %]
[%- pl =  file _ ".pl" -%]
[%- out = file _ "-out.txt" -%]
[% INCLUDE $pl | xtidy %]

produces output

[% INCLUDE $out | xtidy %]

(This example is included as L<F<[% pl %]>|https://fastapi.metacpan.org/source/BKB/XS-Check-[% info.version %]/examples/[% pl %]> in the distribution.)
[% END %]
[% MACRO since(version) BLOCK -%]
This method was added in version [% version %] of the module.
[%- END %]
=encoding UTF-8

=head1 NAME

XS::Check - check XS for problems

=head1 SYNOPSIS

[% example("synopsis") %]

=head1 VERSION

This documents version [% info.version %] of XS::Check corresponding to
L<git commit [% commit.commit %]|[% info.repo %]/commit/[%
commit.commit %]> released on [% commit.date %].

=head1 DESCRIPTION

This module offers ways to check XS files for common flaws.

=head1 METHODS

=head2 new

    my $check = XS::Check->new ();

Make a new XS::Check object. The checks are then run using L</check>
or L</check_file>.

=head3 Changing where the messages go

The messages from L</check> or L</check_file> are usually printed
using Perl's built-in warn function. If you need to have errors
reported some other way, supply a code reference to C<new> with the
key C<reporter> as follows:

    my $usercheck = XS::Check->new (reporter => sub { print "help!" });

The function you supply is then called back when L</check> or L</check_file> find something to remark on. The function is called with a hash containing the
fields

=over

=item file

the file name of the file where the error occurred, if using
L</check_file> or if set with L</set_file>, otherwise the undefined
value (C<undef>),

=item line

the line number where the error occurred, starting from 1,

=item message

the message from the module, a text string.

=back

The following example demonstrates a user-defined callback using the
C<message> and C<line> fields:

[% example("reporter") %]

Callback error reporting was added to the module in version 0.07.

=head2 check

    $check->check ($xs);

See L</SUGGESTIONS> for what this reports.

=head2 check_file

    $check->check ($xs_file);

Convenience method to read in $xs_file then run L</check> on it.

This assumes UTF-8 encoding of $xs_file.

=head2 set_file

    $check->set_file ($file);

Set the file name for error reporting. Use any false value to clear
it. For example:

[% example("set-file") %]

This method was added in version 0.08.

=head1 SUGGESTIONS

This section details the possible suggestions made by the module and
the motivations behind them.

=head2 Use STRLEN in SvPV

Using an int type for the second argument to SvPV may cause errors on
64-bit Perls.

=head2 Use const char * for return value of SvPV

SvPV returns the actual Perl buffer, not a copy, so it's better to use
const char * to make sure one does not overwrite it.

=head2 Don't use malloc/calloc/realloc/free

Replace with Newx etc. 

These cause "free to wrong pool" errors on multithreaded Windows
Perls.

=head2 Don't use the Perl_ prefix

Functions like C<Perl_croak> should not be used, just C<croak>.

This check was added in version 0.04.

=head2 Don't use (void) in arguments

XS functions cannot use the ANSI C C<(void)> to indicate that they do
not take any arguments, instead this results in a variable called
"void" being created.

This check was added in version 0.06.

=head1 LIMITATIONS

As of [% info.version %], the module has the following limitations.

=over

=item Struct members

The module is not very good at parsing struct members, so XS code like
the following doesn't get dealt with properly:

    s.txt = SvPV (sv, s.len);

=item UTF-8 only

L</check_file> uses L<File::Slurper/read_text> to read the text, which
means it only takes UTF-8.

=item Variable declarations rely on a simplistic hack

The current method of parsing variable declarations uses a very
simplistic hack, and it is likely to produce false results if a
variable name is used twice for two different things in the same file.

=item Variables declared within function definitions are not parsed

The following variable C<length> is not dealt with correctly:

    static void
    sv_to_text_fuzzy (SV * text, STRLEN length)
    {
        const unsigned char * stuff;
        /* Copy the string in "text" into "text_fuzzy". */
        stuff = (unsigned char *) SvPV (text, length);

=back

=head1 DEPENDENCIES

=over

=item L<C::Tokenize>

This supplies the regular expressions used to parse C by the module.

=item L<File::Slurper/read_text>

This is used by L</check_file>.

=item L<Text::LineNumber>

This is used to get the line numbers.

=item L<Carp>

=back

=head1 COMMAND-LINE TOOL

A command line tool called C<checkxs> is installed with the module. It
runs the L</check_file> method on each file named on the command line.

    checkxs Some.xs

As of [% info.version %], there are no options to the script. Its
output goes to standard error.

=head1 SEE ALSO

=over

=item L<Perl XS modules and CPAN testers|https://www.lemoda.net/perl/perl-xs-cpan-testers/index.html>

A collection of more or less obscure bugs found by CPAN testers, the
original inspiration for this module.

=back

[% INCLUDE "author" %]
